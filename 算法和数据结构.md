# 算法和数据结构

## 算法基础课程

### 枚举

通过逐个测试获得答案，注意**减少枚举的数量**

**注意考虑枚举范围**

**逆向思维** 确定枚举范围后，如果范围大小足够小，可以尝试全空间枚举搜索

### 递归

- 替代多重循环
- 解决本来就是用递归形式定义的问题
- 将问题分为规模更小的子问题进行求解

### 二分和分治

### 动态规划

### 深度优先搜索

### 广度优先搜索

### 贪心

## 算法和数据结构

### 基本概念

- 数据对象在计算机中的组织方式称为**数据结构**
- 操作数据结构的方法叫做**算法**
- **抽象数据类型(ADT)**与物理结构，编程语言和实现操作的算法无关()

### 复杂度分析

- 空间复杂度 $S(n)$ 和时间复杂度 $T(n)$ 表示规模$n$的问题所需要的空间和时间
- 相比于平均复杂度$T_{avg}(n)$，我们更关心最坏复杂度$T_{worst}(n)$
- **复杂度的渐进表示** $O()$表示上界
- $O(1) < O(log(n)) < O(n) < O(nlog(n)) < O(n^2) < O(2^n) < O(n!) $
- 递归算法三项为$T(n/2)+O(n) +T(n/2)$复杂度为$O(nlog(n))$

### 线性结构

**同类型数据元素构成有序系列的线性结构**

元素个数->长度	没有元素->空表	表其实位置->表头	表结束位置->表尾

#### 顺序结构

- 向量、数组
- 结构数组
- 链表结构

##### 顺序结构的基本操作

- 求表长
- 查找
- 插入
- 删除

##### 广义表

广义表是线性表的一种推广，广义表中的元素不仅可以是单元素也可以是另一个广义表

**矩阵的多重链表表示** 表头，表项和C语言union的用法

#### 堆栈

中缀表达式,后缀表达式,一个数组实现两个堆栈,链表实现堆栈（不用最大栈）

##### 堆栈的基本操作

- 生成堆栈
- 判断堆栈是否满
- **push**将元素item压入堆栈
- 判断堆栈S是否为空
- **pop**删除并返回栈顶元素

#### 队列

使用数组存储队列时有循环队列结构， 链式存储实现

##### 队列的基本操作

- 生成空队列
- 判断队列是否已满
- 将元素插入队列
- 判断队列是否为空
- 将队列头部元素从队列中删除并返回

### 树

#### 树的基本概念

- 层次关系、层次管理

- 方便操作 **例 查找**

  静态查找->只查找，动态查找->查找可能插入和删除

  查找树解决动态查找问题

- 节点的度、树的度、路径和路径长度、祖先节点、子孙节点、结点的层次、树的深度

- 儿子-兄弟表示法

#### 二叉树

任何树将其用儿子兄弟表示法表示后**旋转45度**即可得到二叉树

- 二叉树的五种姿态
- 斜二叉树、完美/满二叉树、完全二叉树
- 二叉树第i层的最大节点数为:$2^{i-1}, i \ge 1$
- 深度为k的二叉树有最大节点总数为:$2^{k}-1, k \ge 1$
- 任何非空二叉树$T$，若$n_0$表示叶节点的个数、$n_2$是度为2的非叶结点个数，那么两者满足关系$n_0=n_2+1$

##### 二叉树的存储结构

- 顺序存储结构存储，完全二叉树可以完美存储，父节点在下标$1/2$处
- 链表存储

##### 二叉树遍历

- 先序、中序、后序遍历

- 层序遍历：核心问题->二维结构的线性化

  使用队列来实现层序遍历

- 使用先序序列和中序序列来确定树

##### 二叉搜索树

- 线性结构也可以实现二分查找，但是二叉搜索树相比于线性结构插入和删除更加方便

- 查找使用循环实现比使用递归实现效率更高

- **如何实现二叉搜索树的删除操作**

  非叶子结点，可以用左右子结点替代，然后根据不同情况调整子树，实现较为复杂

  **也可以用左子树的最大值替代，或者用右子树的最小值替代，仍然成立**:white_check_mark:

- 树的结构不好，例如斜树，查找效率就不会很高，所以会期望平衡二叉树

- 两个序列是否对应相同的搜索树

  1. 建树的判别方法
  2. **不建树的判别方法**->序列比较法
  3. **建立一棵树，再判别是否一致**

##### 平衡二叉树

- 平衡因子 Balance Factor，$BF = H_L-H_R$，左右子树的高度差

- **AVL树**:空树，或者任何一结点左右子树高度差的绝对值不超过1，即$|BF(T)| \le 1$

- **平衡二叉树查找效率的推导**，平均查找长度ASL

  高度为$H$的平衡二叉树至少需要$n_H$个结点，则$n_H = n_{H-1}+n_{H-2}+1$

  即规模为$n_H$的平衡二叉树最少需要$H$次查找

  与斐波那契数列的关系$n_H=F_{H+2}-1$

  由于$F_i=\frac{1}{\sqrt{5}}(\frac{1+\sqrt{5}}{2})^i$

  所以$n_H=\frac{1}{\sqrt{5}}(\frac{1+\sqrt{5}}{2})^{H+2}-1$

  所以$H=O(\log{n})$

- 平衡二叉树的调整，RR调整，LL调整，LR调整，RL调整

### 堆

- 优先级队列，完全二叉树，最大堆和最小堆
- 首先是完全二叉树， 然后每个结点作为根都是所在子树的最小值或最大值
- 堆的价值在于维护一个偏序数据结构，只需要快速的完成最大值最小值的访问

#### 顺序存储完全二叉树子节点与父节点下标关系的证明

- 假设父节点为第$K$层的第$m$个结点，则其子节点为$K+1$层的第$2m-1$和$2m$个结点

  $K+1$层中已经存了$2\times (m-1)$个结点

- 使用等比数列的前$n$项和公式第$K$层的最后一个结点的下标为$2^{K}-1$

- 所以子结点的下标为$2^{K}-1+2m$和$2^{K}-1+2m-1$，父节点的下标为$2^{K-1}-1+m$

- 所以父节点的下标是子结点下标的$1/2$（以1为起始位置）

- 使用整数向下取整时$2m-1$刚好满足整除，$2m$多$1/2$所以向下取证得到的结果一样

#### 堆的基本操作

- 插入，类似冒泡排序
- 删除，尾部的元素拿到头部，然后用向下冒泡的方法
- 最大堆的建立

### 哈夫曼树与哈夫曼编码

- 带权路径，二叉树，**度不唯一**

### 集合

#### 并查集->**路径压缩算法**：Find的时候去压缩路径

### 图

- 表示多对多的关系
- 一组定点，通常用Vertex表示定点的集合，通常用Edge表示边的结合
  - 边是顶点对
  - 有向边<v,w>表示从v指向w的边
  - 不考虑重边和自回路
- 图的操作集合
  - 创建、插入顶点和边、DFS、BFS、计算最短路径、计算最小生成树
- 抽象数据类型定义ADT
  - 类型名称：图Graph
  - 数据对象集：G(V,E)由一个非空的有限顶点集合V和一个有限边集合E组成
  - 操作集：BFS，DFS，Insert

#### 图的表示

- 邻接表和邻接矩阵
- 邻接矩阵
  - 无向图存储可以节省一半的空间
  - 存稀疏图的时候非常浪费空间
- 邻接表
  - 节约稀疏图的存储空间
  - 无向图方便计算顶点的度
  - G[N]为指针数组，对应矩阵每行一个链表，只存非0元素
  - 反复存储顶点，对于网络还要增加权重域，所以一定要足够稀疏才合算

#### 图的遍历

- 深度优先搜索

  - 邻接表$O(N+E)$
  - 邻接矩阵$O(N^2)$

- 广度优先搜索

  - 同样可以使用队列

- 图不连通怎么办

  - **联通** 如果从V到W存在一条（无向）路径，则称V和W是联通的

  - **路径** V到W的路径是一系列顶点{V，... ，W}的集合，其中任意一堆相邻的顶点间都有图中的边。路径的长度是路径中的边树（如果带权，则是所有边的权重和）。如果V到W之间的所有顶点都不同，则称**简单路径**

  - **回路** 起点等于重点的路径

  - **连通图** 图中任意两个顶点连通

  - **连通分量** 无向图的极大连通子图

  - **强连通** V和W之间存在双向路径

  - **强连通图** 有向图中任意两顶点均强连通

  - **强连通分量** 有向图的极大强连通子图


#### 最短路径问题

- **最短路径** (Shortest Path)、 **源点** (Source)、 **终点** (Destination)
- **Dijkstra算法**
- **Floyd算法**

#### 最小生成树问题

- 是一棵树：**无回路**、$V$个顶点一定有$|V|-1$条边
- 是生成树：包含全部顶点、$|V|-1$条边都在图里、任加一条边都构成回路
- 边的权重和最小
- 最小生成树存在<-->图连通

##### 贪心算法

- 贪心算法：每一步都要最好（只要眼前最好）、权重最小的边
- 需要约束：只能用图里有的边、只能正好用掉$|V|-1$条边、不能有回路
- **Prim**算法：从一个根结点让一颗小树长大，在所有与树邻接的边里选择最小的边收入树中
- **Kruskal**算法：将森林合并成树，如何判断回路（并查集）

#### 拓扑排序

- 软件包依赖关系
- **AOV**网络（Activity On Vertex）
- **拓扑序** ：如果图中从V到W有一条有向路径，则V一定排在W之前。满足此条件的顶点序列称为一个拓扑序
- 获得一个拓扑序的过程就是拓扑排序
- AOV网络如果有合理的拓扑序，则必定是有向无环图(Directed Acyclic Graph, DAG)

##### 关键路径问题

- **AOE**（Activity On Edge）网络：一般用于安排项目工序
- 虚边用于解决多依赖
- 多条路径时注意出度为零的最晚值

### 排序

- 排序的稳定性：相等的值排序前后相对位置不对
- 逆序对$I$
- 任意$N$个不同元素组成的序列平均具有$N(N-1)/4$个逆序对
- 任何仅仅以交换相邻两元素来排序的算法(冒泡和插入)，其平均时间复制度为$\Omega(N^2)$
- 每次交换能够消去的逆序对越多，效率越好
- 通过比较完成的排序最快是$O(N\log{N})$

| 排序方法     | 平均时间复杂度              | 最坏时间复杂度 | 额外空间复杂度 | 稳定性 |
| ------------ | --------------------------- | -------------- | -------------- | ------ |
| 简单选择排序 | $O(N^2)$                    | $O(N^2)$       | $O(1)$         | 不稳定 |
| 冒泡排序     | $O(N^2)$                    | $O(N^2)$       | $O(1)$         | 稳定   |
| 直接插入排序 | $O(N^2)$                    | $O(N^2)$       | $O(1)$         | 稳定   |
| 希尔排序     | $O(N^d)$($d$与增量序列有关) | $O(N^2)$       | $O(1)$         | 不稳定 |
| 堆排序       | $O(N\log{N})$               | $O(N\log{N})$  | $O(1)$         | 不稳定 |
| 快速排序     | $O(N\log{N})$               | $O(N^2)$       | $O(\log{N})$   | 不稳定 |
| 归并排序     | $O(N\log{N})$               | $O(N\log{N})$  | $O(N)$         | 稳定   |
| 基数排序     | $O(P(N+B))$                 | $O(P(N+B))$    | $O(N+B)$       | 稳定   |



##### 冒泡排序

```c++
void BubbleSort(ElementType A[], int N) {
    for (P=N-1; P>0; --P) {
        flg = true;
        for (i=0; i<P; ++i) {
            if (A[i] > A[i+1]) {
                Swap(A[i], A[i+1]);
              	flg = false;
            }
        }
        if (flg) break;
    }
}
```

- 最好情况 $T=O(N)$
- 最坏情况$T=O(N^2)$
- 可以设置一个flag，当某一次循环全程无交换时，提前终止排序
- 好处
  1. 稳定性
  2. 适用于链表

##### 插入排序

```c++
void InsertionSort(ElementType A[], int N) {
    for (P=1; P<N; P++) { // 初始时摸入第0张牌
        Tmp = A[P]; // 摸下一张牌
        for (i=P; i>0 && A[i-1]>tmp; i--) // 当前手中有P+1张牌
            A[i] = A[i-1]; // 移出空位
        A[i] = Tmp; // 新牌落位
    }
}
```

- 最好情况$T=O(N)$
- 最坏情况$T=O(N^2)$

##### 希尔排序

```c++
void ShellSort(ElementType A[], int N) {
    for (D=N/2; D>0; D/=2) { // 通过增量序列D将整副牌划分为多个牌组
        for (P=D; P<N; P++) { // 初始时摸入第0张牌，每次下一牌组多摸一张牌
            Tmp = A[P];	// 摸下一张牌
            for (i=P; i>=D && A[i-D]>Tmp; i-=D) 
                A[i] = A[i-D]; // 移出空位
            A[i] = Tmp; // 新牌落位
        }
    }
}
```

- 定义增量序列$D_M>D_{M-1}>\dots>D_1=1$
- 普通序列$T=\Theta(N^2)$，Hibbard增量序列$T = \Theta(N^{3/2})$

##### 选择排序

```c++
void SelectionSort(ElementType A[], int N) {
    for (i=0; i<N; ++i) {
        MinPosition = ScanForMin(A, i, N-1);
        Swap(A[i], A[MinPosition]);
    }
}
```

- 无论如何$T=\Theta（N^2）$
- 主要和查找最小元的算法时间复杂度有关

##### 堆排序算法

```c++
//ALG 1
void HeapSort(ElementType A[], int N) {
    BuildHeap(A);
    for (i=0; i<N; ++i) {
        TmpA[i] = DeleteMin(A);
    }
    memcpy(A, TmpA, N);
}
//ALG 2
void HeapSort(ElementType A[], int N) {
    for (i=N/2; i>=0; i--) { // 建立堆
        PercDown(A, i, N);
    }
    for (i=N-1; i>0; i--) { // 每次将堆的规模减一
        Swap(&A[0], &A[i]); // 删除最大元素
        PercDown(A, 0, i);
    }
}
```

- 用堆来实现选择排序中查找最小元素的操作
- ALG_1的时间复杂度是$T=O(N\log{N})$
- ALG_2稍微好点但是实际应用的效果不如Sedgewick增量序列的希尔排序

##### 归并排序

- 将两个或多个有序列合成一个
- 有序子列的时间复杂度是$T=O(N)$
- 使用递归的方法实现归并排序实现的时间复杂度$O(N\log{N})$
- 使用非递归的方法实现交替使用额外空间
- 是需要额外的内存空间

##### 快速排序

```c++
void QuickSort(ElementType A[], int Left, int Right) {
    if (Cutoff <= Right-Left) {
    	Pivoit = Median3(A, Lefg, Right);
    	i = Left; j = Right -1;
    	for (;;) {
        	while (A[++i] < Pivot) {}
        	while (A[--j] < Pivot) {}
        	if (i < j)
        		Swap(&A[i], &A[j]);
        	else break;
    	}
   		Swap(&A[i]， &A[Right-1]);
    	QuickSort(A, Left, i-1);
    	QuickSort(A, i+1, Right);
    } else {
        InsertionSort(A+Lefg, Right-Left+1)
    }
}
```

- 大规模的随机数据中最好的排序算法
- 每次最好中分$T=O(N\log{N})$
- 最坏的情况$T=O(N^2)$
- 快排的问题
  - 用递归
  - 对于小规模数据可能还不如插入排序快
  - 对于小规模数据直接使用简单排序，如插入排序

##### 表排序

- 当需要移动的元素开销较大的时候
- 不移动元素而只需要移动指针
- 存放指针的数组即为**表**
- 物理排列：N个数字的排列是若干个独立的环组成
- 时间复杂度$T=O(mN)$

##### 桶排序

- 当存在若干组相同的值时，可以设计若干组桶来完成排序
- 时间复杂度$T(N,M) = O(M+N)$,$M$是桶的数量
- 如果$M$的数量小于$N$的值的化线性复杂度比较

##### 基数排序

- 线性时间复杂度
- 多关键字的排序

### 哈希

- **基本思想**：直接计算对象的存储的位置，时间复杂度是常量$O(1)$
- **基本工作**：1）构造散列函数计算位置、2）应用某种策略解决冲突

- **哈希函数构造**

  ```c++
  Index Hash (const char *Key, int TableSize) {
      unsigned int h = 0;
      while (*Key != '\0')
          h = (h << 5) + *Key++;
      return h % TableSize;
  }
  ```

- **冲突解决策略** 直接往下一个位置放

- 

### 串

##### 什么是串

- 线性存储的一组数据（默认是字符）
- 特殊操作集
  - 求串的长度
  - 比较两串是否相等
  - 两串相接
  - 求子串
  - 插入子串
  - **匹配子串**
  - 删除子串

##### KMP(Knuth Morris Pratt)算法

- 待匹配串深入研究，获得尾部的最大匹配子串
- 主要是match函数，获得待匹配串每个位置首尾能配上的小串

```c++
Position KMP(char *string, char *pattern) {
    int n = strlen(string);
    int m = strlen(pattern);
    int s, p, *match;
    if (n < m) return NotFound;
    match = (int *)malloc(sizeof(int) * m);
    BuildMatch(pattern, match);
    s = p = 0;
    while (s<n && p<m) {
        if (string[s]==pattern[p]) {s++; p++;}
        else if (p>0) p = match[p-1] + 1;
        else s++;
    }
    return (p==m)? (s-m) : NotFound;
}
void BuildMatch(pattern, match) {
    int i,j;
    int m = strlen(pattern);
    match[0] = 1;
    for (j=1; j<m; j++) {
        i = match[j-1];
        while ((i>=0) && (pattern[i+1] != pattern[j]))
            i = match[i];
        if (pattern[i+1] == pattern[j])
            match[j] = i+1;
        else match[j] = -1;
    }
}
```

